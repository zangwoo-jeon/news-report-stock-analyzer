# 워크플로우 이름
name: Spring Boot CI with Gradle

# 워크플로우가 실행될 이벤트 정의
on:
  pull_request:
    types: [opened, synchronize, reopened] # PR이 열리거나, 코드가 업데이트되거나, 다시 열릴 때

# 실행될 작업(Job) 정의
jobs:
  # 첫 번째 작업: CI 체크
  ci_check:
    name: Build, Test, and Verify (Gradle)

    # 이 작업이 실행될 환경 (Github Actions Runner)
    # ubuntu-latest는 Docker가 설치되어 있으며, Java/Spring Boot CI에 적합합니다.
    runs-on: ubuntu-latest

    # --- 핵심: 테스트 환경 구축 - PostgreSQL DB 컨테이너 (Step 5, 10 해결) ---
    # services 블록을 사용하여 CI Job이 실행되는 동안 임시 PostgreSQL 컨테이너를 띄웁니다.
    # 이 컨테이너는 Job이 끝나면 자동으로 삭제됩니다.
    services:
      # 서비스 이름 정의 (테스트 코드에서는 'localhost'와 포트로 접근)
      postgres:
        # 사용할 PostgreSQL Docker 이미지 버전 (프로젝트 요구사항에 맞게 조정)
        image: postgres:13
        # 환경 변수 설정 (DB 연결 정보) - 이 정보는 Spring Boot 테스트 설정과 일치해야 합니다.
        env:
          POSTGRES_DB: testdb
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpassword
        # 포트 매핑: 컨테이너 포트(5432)를 Runner의 로컬 호스트 포트(5432)로 매핑합니다.
        # Spring Boot 테스트 코드에서는 'jdbc:postgresql://localhost:5432/testdb' 와 같이 접근합니다.
        ports:
          - 5432:5432
        # 서비스 상태 확인 및 대기: 테스트 실행 전에 DB 컨테이너가 준비될 때까지 기다립니다.
        # services 블록의 health check는 해당 포트가 응답할 때까지 기다립니다.
        options: >-
          --health-cmd "pg_isready -U testuser -d testdb"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10 # 충분히 대기하도록 재시도 횟수를 늘릴 수 있습니다.

    # 작업에서 실행될 단계(Step) 정의 (Step 1 ~ 9)
    steps:
      # 1. PR 코드 체크아웃 (Step 1)
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. 테스트 환경 설정 (Java JDK 설정) (Step 2)
      # 사용하는 Java 버전에 맞게 '17'을 수정하세요 (예: '11', '21')
      # cache: gradle 옵션으로 Gradle 의존성 캐싱을 활성화하여 빌드 속도를 높입니다.
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin" # OpenJDK 배포판 선택 (다른 옵션: 'adopt', 'corretto' 등)
          cache: gradle # Gradle 의존성 캐싱 활성화

      # 3. Gradle Wrapper 권한 설정
      # Linux/Ubuntu 환경에서는 gradlew 스크립트에 실행 권한이 필요합니다.
      - name: Grant execute permission for gradlew
        run: chmod +x back-end/gradlew

      # 4. PostgreSQL DB가 준비될 때까지 대기 (Step 5)
      # services 블록의 health check로 자동 대기되지만, 명시적인 대기 step도 추가 가능
      # 이 Step은 Runner 환경에서 DB 컨테이너의 포트가 열릴 때까지 기다립니다.
      - name: Wait for PostgreSQL to be ready
        run: |
          echo "Waiting for PostgreSQL on localhost:5432..."
          # 'timeout' 명령어를 사용하여 최대 60초까지 대기합니다.
          # pg_isready는 PostgreSQL 클라이언트 도구이며, Runner 이미지에 설치되어 있을 수 있습니다.
          # 만약 pg_isready가 없다면, 다른 포트 체크 도구 (예: wait-for-it.sh 스크립트)를 사용해야 합니다.
          # services 블록의 health check 옵션을 신뢰하고 이 Step을 제거해도 됩니다.
          timeout 60 bash -c 'while ! pg_isready -h localhost -p 5432 -U ${{ jobs.ci_check.services.postgres.env.POSTGRES_USER }} -d ${{ jobs.ci_check.services.postgres.env.POSTGRES_DB }}; do sleep 1; done'
        env: # pg_isready 명령에 필요한 환경 변수 전달 (optional, -U -d 옵션 사용 시)
          PGUSER: ${{ jobs.ci_check.services.postgres.env.POSTGRES_USER }}
          PGDATABASE: ${{ jobs.ci_check.services.postgres.env.POSTGRES_DB }}
          # PGPASSWORD: ${{ jobs.ci_check.services.postgres.env.POSTGRES_PASSWORD }} # 보안상 민감 정보는 환경 변수로 전달 시 주의

      # 5. 애플리케이션 빌드 및 테스트 실행 (Step 3, 4, 6, 7, 8 통합)
      # Gradle의 'check' 태스크를 사용하여 의존성 설치, 컴파일, 유닛/통합 테스트 실행 등을 수행합니다.
      # 이 단계에서 Spring Boot 테스트 환경(@ActiveProfiles("test") 등)이
      # services 블록의 PostgreSQL 컨테이너(localhost:5432)에 연결하도록 설정되어야 합니다.
      # 또한, Spring Boot의 Hibernate DDL auto 또는 Migration 도구(Flyway/Liquibase) 설정이
      # 테스트 시점에 스키마를 자동 적용하도록 구성되어 있어야 합니다.
      - name: Build and Run Tests
        run: |
          echo "Building and running tests with Gradle..."
          cd back-end
          ./gradlew clean check

        env:
          # Spring Boot 테스트가 services 블록의 DB 정보를 환경 변수에서 읽도록 구성되었다면 추가합니다.
          # 일반적인 Spring Boot 설정에서는 application-test.properties 파일 사용을 선호합니다.
          # SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/${{ jobs.ci_check.services.postgres.env.POSTGRES_DB }}
          # SPRING_DATASOURCE_USERNAME: ${{ jobs.ci_check.services.postgres.env.POSTGRES_USER }}
          # SPRING_DATASOURCE_PASSWORD: ${{ jobs.ci_check.services.postgres.env.POSTGRES_PASSWORD }}
          # SPRING_JPA_HIBERNATE_DDL_AUTO: create-drop # 또는 update (테스트 시 스키마 자동 생성/업데이트)
          # SPRING_SQL_INIT_MODE: always # 테스트 데이터 스크립트 자동 실행 (classpath:test-data.sql 등)
          # 필요한 다른 테스트 관련 환경 변수 추가
          TEST_ENVIRONMENT: ci

      # 6. (선택) 테스트 결과 보고 (Step 9 상세)
      # Gradle의 기본 JUnit XML 보고서 경로에서 결과를 가져와 Github UI에 게시합니다.
      - name: Publish Test Results
        # 이전 단계의 성공/실패와 상관없이 항상 실행
        if: always()
        # actions/upload-artifact 액션을 사용하여 결과 파일을 CI 실행 결과에 첨부합니다.
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          # Gradle 기본 JUnit 테스트 보고서 경로. 'test' 태스크 기준.
          path: back-end/build/reports/tests/test/
          retention-days: 5 # 아티팩트 보존 기간


      # 7. (선택) 코드 커버리지 보고 (JaCoCo 사용 시) (Step 9 상세)
      # JaCoCo 등으로 생성된 코드 커버리지 보고서를 Codecov 등에 게시합니다.
      # Codecov 연동은 Codecov 계정 설정 및 토큰 설정이 필요할 수 있습니다.
      # - name: Publish Code Coverage # Codecov 연동 예시
      #   uses: codecov/codecov-action@v4
      #   if: always() # 이전 단계 성공/실패와 상관없이 항상 실행
      #   with:
      #     # Gradle JaCoCo 기본 보고서 경로. 'test' 태스크가 JaCoCo 리포트를 생성하도록 설정되어 있어야 함.
      #     files: ./build/reports/jacoco/test/jacocoTestReport.xml
      #     fail_ci_if_error: true # Codecov 보고 오류 시 CI 실패 처리
      #     verbose: true # 상세 로그 출력

      # 8. (선택) 추가적인 정적 분석 또는 검사 (Step 4 상세)
      # SpotBugs, Checkstyle, PMD 등 추가적인 정적 분석 도구 실행
      # 프로젝트 build.gradle에 해당 플러그인이 설정되어 있어야 합니다.
      # - name: Run Static Analysis
      #   run: |
      #     ./gradlew spotbugsMain spotbugsTest checkstyleMain checkstyleTest
      #     # 필요한 Gradle 태스크 실행
